{% extends "base.html" %}

{% block content %}
<h2>{{ channel.channel_name or '[Unnamed Channel]' }} Details</h2>
<div class="channel-meta">
    <span class="meta-item">ID: {{ channel.channel_id }}</span>
    {% if channel.last_synced %}
    <span class="meta-item">Last synced: {{ channel.last_synced.strftime('%Y-%m-%d %H:%M') }}</span>
    {% else %}
    <span class="meta-item">Last synced: Never</span>
    {% endif %}
</div>

<!-- Progress Panel -->
<div id="progress-panel" class="progress-panel hidden">
    <div class="progress-header">
        <span id="progress-title">Operation in progress...</span>
        <div class="progress-controls">
            <span id="progress-status" class="status-badge">running</span>
            <button type="button" id="stop-btn" class="stop-btn" onclick="stopTask()">Stop</button>
        </div>
    </div>
    <div class="progress-bar-container">
        <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
    </div>
    <div id="progress-message" class="progress-message">Starting...</div>
</div>

<!-- Statistics -->
<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-label">Videos</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ video_downloaded }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ video_count }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ video_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ video_size }}</span>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Images</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ image_downloaded }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ image_count }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ image_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ image_size }}</span>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Other</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ other_downloaded }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ other_count }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ other_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ other_size }}</span>
        </div>
    </div>
    <div class="stat-card total">
        <div class="stat-label">Total</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ downloaded_media }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ all_media }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ total_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ total_size }}</span>
        </div>
    </div>
</div>
<div class="stats-legend">
    <span class="legend-item"><span class="legend-color downloaded"></span> Downloaded</span>
    <span class="legend-item"><span class="legend-color total"></span> Total</span>
</div>

<!-- Tabs -->
<div class="tabs">
    <button type="button" class="tab-btn active" onclick="switchTab('actions')">Actions</button>
    <button type="button" class="tab-btn" onclick="switchTab('storage')">Storage</button>
    <button type="button" class="tab-btn" onclick="switchTab('library')">Media Library</button>
</div>

<!-- Tab: Actions -->
<div id="tab-actions" class="tab-content active">
    <div class="action-row">
        <div class="action-info">
            <span class="action-label">Fetch Messages</span>
            <span class="action-detail">Scan channel for new media</span>
        </div>
        <button type="button" id="fetch-btn" class="action-btn" onclick="startFetch()">
            <span class="btn-text">Fetch</span>
            <span class="btn-spinner hidden"></span>
        </button>
    </div>
    <div class="action-row">
        <div class="action-info">
            <span class="action-label">Download Media</span>
            <span class="action-detail" id="pending-info">{{ not_downloaded_media }} pending</span>
        </div>
        <button type="button" id="download-btn" class="action-btn" onclick="startDownload()">
            <span class="btn-text">Download</span>
            <span class="btn-spinner hidden"></span>
        </button>
    </div>
    <div class="action-row">
        <div class="action-info">
            <span class="action-label">Sync Storage</span>
            <span class="action-detail">Verify files, find duplicates, handle orphans</span>
        </div>
        <button type="button" id="sync-btn" class="action-btn" onclick="startSync()">
            <span class="btn-text">Sync</span>
            <span class="btn-spinner hidden"></span>
        </button>
    </div>

    <div class="danger-zone">
        <h3>Danger Zone</h3>
        <p>This will delete all fetched media info from the database for this channel. Downloaded files will not be deleted.</p>
        <button type="button" id="reset-btn" class="danger-btn" onclick="confirmReset()">Reset Channel Data</button>
    </div>
</div>

<!-- Tab: Storage -->
<div id="tab-storage" class="tab-content">
    <div id="storage-loading" class="storage-loading">Loading storage info...</div>
    <div id="storage-content" class="hidden">
        <div class="storage-header">
            <div class="storage-path-row">
                <span class="storage-label">Path:</span>
                <code id="storage-path" class="storage-path"></code>
                <button type="button" class="copy-btn" onclick="copyPath()" title="Copy path">Copy</button>
            </div>
            <div id="storage-warning" class="storage-warning hidden">
                <span class="warning-icon">!</span>
                <span class="warning-text">Mismatch: DB and disk file counts differ</span>
                <button type="button" class="action-btn small" onclick="switchTab('actions'); startSync();">Sync</button>
            </div>
        </div>
        <div class="storage-stats">
            <div class="storage-stat">
                <span class="stat-value" id="storage-file-count">0</span>
                <span class="stat-label">Files on disk</span>
            </div>
            <div class="storage-stat">
                <span class="stat-value" id="storage-total-size">0 B</span>
                <span class="stat-label">Total size</span>
            </div>
            <div class="storage-stat">
                <span class="stat-value" id="db-downloaded-count">0</span>
                <span class="stat-label">Downloaded (DB)</span>
            </div>
        </div>
        <div class="extensions-section">
            <span class="storage-label">Extensions:</span>
            <div id="extensions-list" class="extensions-list"></div>
        </div>
        <div class="files-section">
            <button type="button" class="collapsible" onclick="toggleFileList()">
                <span id="files-toggle-icon">+</span>
                <span>File List (<span id="files-count">0</span> files)</span>
            </button>
            <div id="files-list" class="files-list hidden"></div>
        </div>
    </div>
    <div id="storage-empty" class="storage-empty hidden">
        <span>No folder exists yet. Download media to create it.</span>
    </div>
</div>

<!-- Tab: Media Library -->
<div id="tab-library" class="tab-content">
    <div class="media-filters">
        <select id="media-type-filter" onchange="loadMediaList()">
            <option value="">All Types</option>
            <option value="video">Videos</option>
            <option value="image">Images</option>
            <option value="audio">Audio</option>
        </select>
        <select id="download-filter" onchange="loadMediaList()">
            <option value="">All Status</option>
            <option value="true">Downloaded</option>
            <option value="false">Pending</option>
        </select>
        <select id="sort-by-filter" onchange="loadMediaList()">
            <option value="date">Sort by Date</option>
            <option value="size">Sort by Size</option>
            <option value="duration">Sort by Duration</option>
            <option value="name">Sort by Name</option>
        </select>
        <select id="sort-order-filter" onchange="loadMediaList()">
            <option value="desc">Descending</option>
            <option value="asc">Ascending</option>
        </select>
        <span id="media-count" class="media-count"></span>
    </div>
    <div id="media-list-loading" class="storage-loading">Loading media...</div>
    <div id="media-list" class="media-list hidden"></div>
    <div id="media-pagination" class="media-pagination hidden">
        <button type="button" class="action-btn small" id="prev-btn" onclick="prevPage()" disabled>Prev</button>
        <span id="page-info"></span>
        <button type="button" class="action-btn small" id="next-btn" onclick="nextPage()">Next</button>
    </div>
</div>

<!-- Confirmation Modal -->
<div id="confirm-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Confirm Reset</h3>
        <p>Are you sure you want to delete all media records for this channel?</p>
        <p><strong>{{ all_media }}</strong> records will be deleted.</p>
        <div class="modal-buttons">
            <button type="button" class="action-btn" onclick="closeModal()">Cancel</button>
            <button type="button" class="danger-btn" onclick="resetChannel()">Yes, Reset</button>
        </div>
    </div>
</div>

<script>
const channelId = "{{ channel.channel_id }}";
let eventSource = null;
let currentTaskId = null;
let currentBtnId = null;
let storageLoaded = false;
let libraryLoaded = false;

// Tab switching
function switchTab(tabName) {
    // Update buttons
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');

    // Update content
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    document.getElementById('tab-' + tabName).classList.add('active');

    // Lazy load content
    if (tabName === 'storage' && !storageLoaded) {
        loadStorageInfo();
        storageLoaded = true;
    }
    if (tabName === 'library' && !libraryLoaded) {
        loadMediaList();
        libraryLoaded = true;
    }
}

function showProgress(title) {
    const panel = document.getElementById('progress-panel');
    document.getElementById('progress-title').textContent = title;
    document.getElementById('progress-status').textContent = 'starting';
    document.getElementById('progress-status').className = 'status-badge running';
    document.getElementById('progress-bar').style.width = '0%';
    document.getElementById('progress-message').textContent = 'Starting...';
    document.getElementById('stop-btn').disabled = false;
    panel.classList.remove('hidden');
}

function updateProgress(data) {
    const pct = data.total > 0 ? Math.round((data.current / data.total) * 100) : 0;
    document.getElementById('progress-bar').style.width = pct + '%';
    document.getElementById('progress-message').textContent = data.message;
    document.getElementById('progress-status').textContent = data.status;
    document.getElementById('progress-status').className = 'status-badge ' + data.status;
}

function hideProgressDelayed() {
    setTimeout(() => {
        document.getElementById('progress-panel').classList.add('hidden');
        currentTaskId = null;
    }, 3000);
}

function setButtonLoading(btnId, loading) {
    if (!btnId) return;
    const btn = document.getElementById(btnId);
    if (!btn) return;
    const text = btn.querySelector('.btn-text');
    const spinner = btn.querySelector('.btn-spinner');

    if (loading) {
        btn.disabled = true;
        if (text) text.classList.add('hidden');
        if (spinner) spinner.classList.remove('hidden');
    } else {
        btn.disabled = false;
        if (text) text.classList.remove('hidden');
        if (spinner) spinner.classList.add('hidden');
    }
}

function subscribeToProgress(taskId, btnId, title) {
    currentTaskId = taskId;
    currentBtnId = btnId;
    showProgress(title);

    eventSource = new EventSource('/task_progress/' + taskId);

    eventSource.onmessage = function(event) {
        const data = JSON.parse(event.data);
        updateProgress(data);

        if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {
            eventSource.close();
            setButtonLoading(btnId, false);
            document.getElementById('stop-btn').disabled = true;
            hideProgressDelayed();
            if (data.status === 'completed' || data.status === 'cancelled') {
                setTimeout(() => location.reload(), 2000);
            }
        }
    };

    eventSource.onerror = function() {
        eventSource.close();
        setButtonLoading(btnId, false);
        document.getElementById('stop-btn').disabled = true;
        document.getElementById('progress-status').textContent = 'error';
        document.getElementById('progress-status').className = 'status-badge failed';
        hideProgressDelayed();
    };
}

async function stopTask() {
    if (!currentTaskId) return;

    document.getElementById('stop-btn').disabled = true;
    document.getElementById('progress-message').textContent = 'Stopping...';

    try {
        await fetch('/stop_task/' + currentTaskId, { method: 'POST' });
    } catch (error) {
        console.error('Failed to stop task:', error);
    }
}

async function startFetch() {
    setButtonLoading('fetch-btn', true);

    try {
        const response = await fetch('/fetch_messages/?channel_id=' + channelId, {
            method: 'POST'
        });
        const data = await response.json();

        if (data.task_id) {
            subscribeToProgress(data.task_id, 'fetch-btn', 'Fetching messages...');
        }
    } catch (error) {
        setButtonLoading('fetch-btn', false);
        alert('Failed to start fetch: ' + error);
    }
}

async function startDownload() {
    setButtonLoading('download-btn', true);

    try {
        const response = await fetch('/download_media_from_channel/?channel_id=' + channelId, {
            method: 'POST'
        });
        const data = await response.json();

        if (data.task_id) {
            subscribeToProgress(data.task_id, 'download-btn', 'Downloading media...');
        }
    } catch (error) {
        setButtonLoading('download-btn', false);
        alert('Failed to start download: ' + error);
    }
}

function confirmReset() {
    document.getElementById('confirm-modal').classList.remove('hidden');
}

function closeModal() {
    document.getElementById('confirm-modal').classList.add('hidden');
}

async function resetChannel() {
    closeModal();
    document.getElementById('reset-btn').disabled = true;
    document.getElementById('reset-btn').textContent = 'Resetting...';

    try {
        const response = await fetch('/reset_channel/' + channelId, { method: 'POST' });
        const data = await response.json();

        if (data.status === 'success') {
            alert('Deleted ' + data.deleted + ' records');
            location.reload();
        } else {
            alert('Reset failed');
            document.getElementById('reset-btn').disabled = false;
            document.getElementById('reset-btn').textContent = 'Reset Channel Data';
        }
    } catch (error) {
        alert('Reset failed: ' + error);
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('reset-btn').textContent = 'Reset Channel Data';
    }
}

// Storage Panel Functions
let storagePath = '';

async function loadStorageInfo() {
    try {
        const response = await fetch('/storage_info/' + channelId);
        const data = await response.json();

        document.getElementById('storage-loading').classList.add('hidden');

        if (data.error) {
            document.getElementById('storage-empty').classList.remove('hidden');
            document.getElementById('storage-empty').querySelector('span').textContent = data.error;
            return;
        }

        if (!data.exists) {
            document.getElementById('storage-empty').classList.remove('hidden');
            return;
        }

        document.getElementById('storage-content').classList.remove('hidden');
        storagePath = data.path;

        document.getElementById('storage-path').textContent = data.path;
        document.getElementById('storage-file-count').textContent = data.file_count;
        document.getElementById('storage-total-size').textContent = data.total_size_formatted;
        document.getElementById('db-downloaded-count').textContent = data.db_downloaded_count;
        document.getElementById('files-count').textContent = data.file_count;

        // Show warning if mismatch
        if (data.mismatch) {
            document.getElementById('storage-warning').classList.remove('hidden');
        }

        // Render extensions
        const extList = document.getElementById('extensions-list');
        extList.innerHTML = '';
        for (const [ext, info] of Object.entries(data.extensions)) {
            const tag = document.createElement('span');
            tag.className = 'ext-tag';
            tag.textContent = ext + ' (' + info.count + ', ' + info.size_formatted + ')';
            extList.appendChild(tag);
        }

        // Render file list
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '';
        for (const file of data.files) {
            const row = document.createElement('div');
            row.className = 'file-row';
            row.innerHTML = '<span class="file-name">' + escapeHtml(file.name) + '</span>' +
                           '<span class="file-size">' + file.size_formatted + '</span>';
            filesList.appendChild(row);
        }
    } catch (error) {
        document.getElementById('storage-loading').classList.add('hidden');
        document.getElementById('storage-empty').classList.remove('hidden');
        document.getElementById('storage-empty').querySelector('span').textContent = 'Failed to load storage info';
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function copyPath() {
    navigator.clipboard.writeText(storagePath).then(() => {
        const btn = document.querySelector('.copy-btn');
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
    });
}

function toggleFileList() {
    const list = document.getElementById('files-list');
    const icon = document.getElementById('files-toggle-icon');
    if (list.classList.contains('hidden')) {
        list.classList.remove('hidden');
        icon.textContent = '-';
    } else {
        list.classList.add('hidden');
        icon.textContent = '+';
    }
}

async function startSync() {
    setButtonLoading('sync-btn', true);

    try {
        const response = await fetch('/sync_channel/?channel_id=' + channelId, {
            method: 'POST'
        });
        const data = await response.json();

        if (data.task_id) {
            subscribeToProgress(data.task_id, 'sync-btn', 'Syncing storage...');
        } else if (data.error) {
            setButtonLoading('sync-btn', false);
            alert('Sync failed: ' + data.error);
        }
    } catch (error) {
        setButtonLoading('sync-btn', false);
        alert('Failed to start sync: ' + error);
    }
}

// Media List Functions
let mediaOffset = 0;
const mediaLimit = 50;
let mediaTotal = 0;

async function loadMediaList(resetOffset = true) {
    if (resetOffset) mediaOffset = 0;

    const typeFilter = document.getElementById('media-type-filter').value;
    const downloadFilter = document.getElementById('download-filter').value;
    const sortBy = document.getElementById('sort-by-filter').value;
    const sortOrder = document.getElementById('sort-order-filter').value;

    let url = `/media_list/${channelId}?limit=${mediaLimit}&offset=${mediaOffset}`;
    if (typeFilter) url += `&media_type=${typeFilter}`;
    if (downloadFilter) url += `&downloaded=${downloadFilter}`;
    url += `&sort_by=${sortBy}&sort_order=${sortOrder}`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        document.getElementById('media-list-loading').classList.add('hidden');
        document.getElementById('media-list').classList.remove('hidden');
        document.getElementById('media-pagination').classList.remove('hidden');

        mediaTotal = data.total;
        document.getElementById('media-count').textContent = `${data.total} items`;

        const list = document.getElementById('media-list');
        list.innerHTML = '';

        if (data.items.length === 0) {
            list.innerHTML = '<div class="no-media">No media found</div>';
            document.getElementById('media-pagination').classList.add('hidden');
            return;
        }

        for (const item of data.items) {
            const row = document.createElement('div');
            row.className = 'media-item' + (item.is_duplicate ? ' duplicate' : '');

            const typeIcon = getTypeIcon(item.media_type);
            const status = item.is_downloaded ? '<span class="status-downloaded">Downloaded</span>' :
                          (item.is_duplicate ? '<span class="status-duplicate">Duplicate</span>' :
                          '<span class="status-pending">Pending</span>');

            let details = [];
            if (item.resolution) details.push(item.resolution);
            if (item.duration_formatted) details.push(item.duration_formatted);
            if (item.size_formatted) details.push(item.size_formatted);

            const name = item.original_filename || item.filename || `Media #${item.tg_message_id}`;
            const date = item.message_date ? new Date(item.message_date).toLocaleDateString() : '';

            row.innerHTML = `
                <div class="media-icon">${typeIcon}</div>
                <div class="media-info">
                    <div class="media-name" title="${escapeHtml(name)}">${escapeHtml(name)}</div>
                    <div class="media-details">${details.join(' | ')}</div>
                    ${item.caption ? `<div class="media-caption">${escapeHtml(item.caption)}</div>` : ''}
                </div>
                <div class="media-meta">
                    <div>${status}</div>
                    <div class="media-date">${date}</div>
                </div>
            `;
            list.appendChild(row);
        }

        updatePagination();
    } catch (error) {
        document.getElementById('media-list-loading').classList.add('hidden');
        document.getElementById('media-list').classList.remove('hidden');
        document.getElementById('media-list').innerHTML = '<div class="no-media">Failed to load media</div>';
    }
}

function getTypeIcon(mimeType) {
    if (!mimeType) return '?';
    if (mimeType.startsWith('video')) return 'V';
    if (mimeType.startsWith('image')) return 'I';
    if (mimeType.startsWith('audio')) return 'A';
    return 'F';
}

function updatePagination() {
    const totalPages = Math.ceil(mediaTotal / mediaLimit);
    const currentPage = Math.floor(mediaOffset / mediaLimit) + 1;

    document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages}`;
    document.getElementById('prev-btn').disabled = mediaOffset === 0;
    document.getElementById('next-btn').disabled = mediaOffset + mediaLimit >= mediaTotal;
}

function prevPage() {
    if (mediaOffset > 0) {
        mediaOffset -= mediaLimit;
        loadMediaList(false);
    }
}

function nextPage() {
    if (mediaOffset + mediaLimit < mediaTotal) {
        mediaOffset += mediaLimit;
        loadMediaList(false);
    }
}
</script>
{% endblock %}
