{% extends "base.html" %}

{% block content %}
<h2>{{ channel.channel_name or '[Unnamed Channel]' }} Details</h2>
<div class="channel-meta">
    <span class="meta-item">ID: {{ channel.channel_id }}</span>
    {% if channel.last_synced %}
    <span class="meta-item">Last synced: {{ channel.last_synced.strftime('%Y-%m-%d %H:%M') }}</span>
    {% else %}
    <span class="meta-item">Last synced: Never</span>
    {% endif %}
</div>

<!-- Progress Panel -->
<div id="progress-panel" class="progress-panel hidden">
    <div class="progress-header">
        <span id="progress-title">Operation in progress...</span>
        <span id="progress-status" class="status-badge">running</span>
    </div>
    <div class="progress-bar-container">
        <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
    </div>
    <div id="progress-message" class="progress-message">Starting...</div>
</div>

<!-- Statistics -->
<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-label">Videos</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ video_downloaded }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ video_count }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ video_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ video_size }}</span>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Images</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ image_downloaded }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ image_count }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ image_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ image_size }}</span>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Other</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ other_downloaded }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ other_count }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ other_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ other_size }}</span>
        </div>
    </div>
    <div class="stat-card total">
        <div class="stat-label">Total</div>
        <div class="stat-row">
            <span class="stat-downloaded">{{ downloaded_media }}</span>
            <span class="stat-separator">/</span>
            <span class="stat-total">{{ all_media }}</span>
        </div>
        <div class="stat-size-row">
            <span class="size-downloaded">{{ total_downloaded_size }}</span>
            <span class="stat-separator">/</span>
            <span class="size-total">{{ total_size }}</span>
        </div>
    </div>
</div>
<div class="stats-legend">
    <span class="legend-item"><span class="legend-color downloaded"></span> Downloaded</span>
    <span class="legend-item"><span class="legend-color total"></span> Total</span>
</div>

<!-- Tabs -->
<div class="tabs">
    <button type="button" class="tab-btn active" onclick="switchTab('actions')">Actions</button>
    <button type="button" class="tab-btn" onclick="switchTab('stats')">Stats</button>
    <button type="button" class="tab-btn" onclick="switchTab('library')">Media Library</button>
</div>

<!-- Tab: Actions -->
<div id="tab-actions" class="tab-content active">
    <div class="action-row">
        <div class="action-info">
            <span class="action-label">Fetch Messages</span>
            <span class="action-detail">Scan channel for new media</span>
        </div>
        <button type="button" id="fetch-btn" class="action-btn" onclick="startFetch()">
            <span class="btn-text">Fetch</span>
            <span class="btn-spinner hidden"></span>
        </button>
    </div>
    <div class="action-row">
        <div class="action-info">
            <span class="action-label">Download Media</span>
            <span class="action-detail" id="pending-info">{{ not_downloaded_media }} pending</span>
        </div>
        <button type="button" id="download-btn" class="action-btn" onclick="startDownload()">
            <span class="btn-text">Download</span>
            <span class="btn-spinner hidden"></span>
        </button>
    </div>
    <div class="action-row">
        <div class="action-info">
            <span class="action-label">Sync Storage</span>
            <span class="action-detail">Verify files, find duplicates, handle orphans</span>
        </div>
        <button type="button" id="sync-btn" class="action-btn" onclick="startSync()">
            <span class="btn-text">Sync</span>
            <span class="btn-spinner hidden"></span>
        </button>
    </div>

    <div class="danger-zone">
        <h3>Danger Zone</h3>
        <p>This will delete all fetched media info from the database for this channel. Downloaded files will not be deleted.</p>
        <button type="button" id="reset-btn" class="danger-btn" onclick="confirmReset()">Reset Channel Data</button>
    </div>
</div>

<!-- Tab: Stats -->
<div id="tab-stats" class="tab-content">
    <div id="stats-loading" class="storage-loading">Loading statistics...</div>
    <div id="stats-content" class="hidden">
        <!-- Content Overview -->
        <div class="stats-section">
            <h3>Content Overview</h3>
            <div class="content-overview-grid">
                <div class="overview-stat">
                    <span class="overview-value" id="total-duration">-</span>
                    <span class="overview-label">Total Video Duration</span>
                </div>
                <div class="overview-stat">
                    <span class="overview-value" id="avg-duration">-</span>
                    <span class="overview-label">Average Duration</span>
                </div>
                <div class="overview-stat">
                    <span class="overview-value" id="videos-analyzed">-</span>
                    <span class="overview-label">Videos Analyzed</span>
                </div>
                <div class="overview-stat">
                    <span class="overview-value" id="duplicates-info">-</span>
                    <span class="overview-label">Duplicates Detected</span>
                </div>
            </div>
        </div>

        <!-- Charts Row -->
        <div class="charts-row">
            <!-- Duration Distribution -->
            <div class="chart-container">
                <h3>Video Duration Distribution</h3>
                <div class="chart-wrapper">
                    <canvas id="duration-chart"></canvas>
                </div>
            </div>

            <!-- Resolution Distribution -->
            <div class="chart-container">
                <h3>Resolution Distribution</h3>
                <div class="chart-wrapper">
                    <canvas id="resolution-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Activity Timeline -->
        <div class="stats-section">
            <h3>Activity Timeline (Last 12 Months)</h3>
            <div class="chart-container-wide">
                <div class="chart-wrapper-wide">
                    <canvas id="activity-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Top Content -->
        <div class="top-content-row">
            <div class="top-content-section">
                <h3>Longest Videos</h3>
                <div id="longest-videos" class="top-list"></div>
            </div>
            <div class="top-content-section">
                <h3>Largest Files</h3>
                <div id="largest-files" class="top-list"></div>
            </div>
        </div>
    </div>
    <div id="stats-empty" class="storage-empty hidden">
        <span>No data available. Download media first.</span>
    </div>
</div>

<!-- Tab: Media Library -->
<div id="tab-library" class="tab-content">
    <div class="media-filters">
        <select id="media-type-filter" onchange="loadMediaList()">
            <option value="">All Types</option>
            <option value="video">Videos</option>
            <option value="image">Images</option>
            <option value="audio">Audio</option>
        </select>
        <select id="download-filter" onchange="loadMediaList()">
            <option value="">All Status</option>
            <option value="true">Downloaded</option>
            <option value="false">Pending</option>
        </select>
        <select id="sort-by-filter" onchange="loadMediaList()">
            <option value="date">Sort by Date</option>
            <option value="size">Sort by Size</option>
            <option value="duration">Sort by Duration</option>
            <option value="name">Sort by Name</option>
        </select>
        <select id="sort-order-filter" onchange="loadMediaList()">
            <option value="desc">Descending</option>
            <option value="asc">Ascending</option>
        </select>
        <span id="media-count" class="media-count"></span>
    </div>
    <div id="media-list-loading" class="storage-loading">Loading media...</div>
    <div id="media-list" class="media-list hidden"></div>
    <div id="media-pagination" class="media-pagination hidden">
        <button type="button" class="action-btn small" id="prev-btn" onclick="prevPage()" disabled>Prev</button>
        <span id="page-info"></span>
        <button type="button" class="action-btn small" id="next-btn" onclick="nextPage()">Next</button>
    </div>
</div>

<!-- Confirmation Modal -->
<div id="confirm-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Confirm Reset</h3>
        <p>Are you sure you want to delete all media records for this channel?</p>
        <p><strong>{{ all_media }}</strong> records will be deleted.</p>
        <div class="modal-buttons">
            <button type="button" class="action-btn" onclick="closeModal()">Cancel</button>
            <button type="button" class="danger-btn" onclick="resetChannel()">Yes, Reset</button>
        </div>
    </div>
</div>

<script>
const channelId = "{{ channel.channel_id }}";
let eventSource = null;
let currentTaskId = null;
let currentBtnId = null;
let currentOperation = null;
let statsLoaded = false;
let libraryLoaded = false;

// Chart instances
let durationChart = null;
let resolutionChart = null;
let activityChart = null;

// Operation to button/title mapping
const operationConfig = {
    fetch: { btnId: 'fetch-btn', title: 'Fetching messages...', label: 'Fetch' },
    download: { btnId: 'download-btn', title: 'Downloading media...', label: 'Download' },
    sync: { btnId: 'sync-btn', title: 'Syncing storage...', label: 'Sync' }
};

// Check for active tasks on page load
async function checkActiveTasks() {
    try {
        const response = await fetch('/active_tasks/' + channelId);
        const tasks = await response.json();

        // Check each operation type
        for (const [operation, taskInfo] of Object.entries(tasks)) {
            if (taskInfo && taskInfo.status === 'running') {
                const config = operationConfig[operation];
                if (config) {
                    // Set up UI for active task
                    currentOperation = operation;
                    setButtonLoading(config.btnId, true);
                    setButtonStopMode(config.btnId, operation);

                    // Subscribe to progress stream
                    subscribeToProgress(taskInfo.task_id, config.btnId, config.title);

                    // Update progress with current state
                    updateProgress({
                        current: taskInfo.current,
                        total: taskInfo.total,
                        message: taskInfo.message,
                        status: taskInfo.status
                    });

                    // Only handle one active task at a time
                    break;
                }
            }
        }
    } catch (error) {
        console.error('Failed to check active tasks:', error);
    }
}

function setButtonStopMode(btnId, operation) {
    const btn = document.getElementById(btnId);
    if (!btn) return;

    const config = operationConfig[operation];
    const text = btn.querySelector('.btn-text');
    const spinner = btn.querySelector('.btn-spinner');

    // Show text, hide spinner, change to Stop mode
    if (text) {
        text.classList.remove('hidden');
        text.textContent = 'Stop';
    }
    if (spinner) spinner.classList.add('hidden');

    btn.disabled = false;
    btn.classList.add('stop-mode');
    btn.onclick = () => stopCurrentTask(operation);
}

function resetButtonNormalMode(btnId, operation) {
    const btn = document.getElementById(btnId);
    if (!btn) return;

    const config = operationConfig[operation];
    const text = btn.querySelector('.btn-text');

    if (text) text.textContent = config.label;
    btn.classList.remove('stop-mode');
    btn.disabled = false;

    // Restore original onclick
    if (operation === 'fetch') btn.onclick = startFetch;
    else if (operation === 'download') btn.onclick = startDownload;
    else if (operation === 'sync') btn.onclick = startSync;
}

async function stopCurrentTask(operation) {
    if (!currentTaskId) return;

    const config = operationConfig[operation];
    const btn = document.getElementById(config.btnId);
    if (btn) btn.disabled = true;

    document.getElementById('progress-message').textContent = 'Stopping...';

    try {
        await fetch('/stop_task/' + currentTaskId, { method: 'POST' });
    } catch (error) {
        console.error('Failed to stop task:', error);
    }
}

// Tab switching
function switchTab(tabName) {
    // Update buttons
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');

    // Update content
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    document.getElementById('tab-' + tabName).classList.add('active');

    // Lazy load content
    if (tabName === 'stats' && !statsLoaded) {
        loadContentStats();
        statsLoaded = true;
    }
    if (tabName === 'library' && !libraryLoaded) {
        loadMediaList();
        libraryLoaded = true;
    }
}

function showProgress(title) {
    const panel = document.getElementById('progress-panel');
    document.getElementById('progress-title').textContent = title;
    document.getElementById('progress-status').textContent = 'starting';
    document.getElementById('progress-status').className = 'status-badge running';
    document.getElementById('progress-bar').style.width = '0%';
    document.getElementById('progress-message').textContent = 'Starting...';
    panel.classList.remove('hidden');
}

function updateProgress(data) {
    const pct = data.total > 0 ? Math.round((data.current / data.total) * 100) : 0;
    document.getElementById('progress-bar').style.width = pct + '%';
    document.getElementById('progress-message').textContent = data.message;
    document.getElementById('progress-status').textContent = data.status;
    document.getElementById('progress-status').className = 'status-badge ' + data.status;
}

function hideProgressDelayed() {
    setTimeout(() => {
        document.getElementById('progress-panel').classList.add('hidden');
        currentTaskId = null;
    }, 3000);
}

function setButtonLoading(btnId, loading) {
    if (!btnId) return;
    const btn = document.getElementById(btnId);
    if (!btn) return;
    const text = btn.querySelector('.btn-text');
    const spinner = btn.querySelector('.btn-spinner');

    if (loading) {
        btn.disabled = true;
        if (text) text.classList.add('hidden');
        if (spinner) spinner.classList.remove('hidden');
    } else {
        btn.disabled = false;
        if (text) text.classList.remove('hidden');
        if (spinner) spinner.classList.add('hidden');
    }
}

function subscribeToProgress(taskId, btnId, title, operation = null) {
    currentTaskId = taskId;
    currentBtnId = btnId;
    if (operation) currentOperation = operation;
    showProgress(title);

    eventSource = new EventSource('/task_progress/' + taskId);

    eventSource.onmessage = function(event) {
        const data = JSON.parse(event.data);
        updateProgress(data);

        if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {
            eventSource.close();
            setButtonLoading(btnId, false);
            if (currentOperation) {
                resetButtonNormalMode(btnId, currentOperation);
            }
            hideProgressDelayed();
            currentOperation = null;
            if (data.status === 'completed' || data.status === 'cancelled') {
                setTimeout(() => location.reload(), 2000);
            }
        }
    };

    eventSource.onerror = function() {
        eventSource.close();
        setButtonLoading(btnId, false);
        if (currentOperation) {
            resetButtonNormalMode(btnId, currentOperation);
        }
        document.getElementById('progress-status').textContent = 'error';
        document.getElementById('progress-status').className = 'status-badge failed';
        hideProgressDelayed();
        currentOperation = null;
    };
}

async function startFetch() {
    setButtonLoading('fetch-btn', true);

    try {
        const response = await fetch('/fetch_messages/?channel_id=' + channelId, {
            method: 'POST'
        });
        const data = await response.json();

        if (data.task_id) {
            currentOperation = 'fetch';
            setButtonStopMode('fetch-btn', 'fetch');
            subscribeToProgress(data.task_id, 'fetch-btn', 'Fetching messages...', 'fetch');
        }
    } catch (error) {
        setButtonLoading('fetch-btn', false);
        alert('Failed to start fetch: ' + error);
    }
}

async function startDownload() {
    setButtonLoading('download-btn', true);

    try {
        const response = await fetch('/download_media_from_channel/?channel_id=' + channelId, {
            method: 'POST'
        });
        const data = await response.json();

        if (data.task_id) {
            currentOperation = 'download';
            setButtonStopMode('download-btn', 'download');
            subscribeToProgress(data.task_id, 'download-btn', 'Downloading media...', 'download');
        }
    } catch (error) {
        setButtonLoading('download-btn', false);
        alert('Failed to start download: ' + error);
    }
}

function confirmReset() {
    document.getElementById('confirm-modal').classList.remove('hidden');
}

function closeModal() {
    document.getElementById('confirm-modal').classList.add('hidden');
}

async function resetChannel() {
    closeModal();
    document.getElementById('reset-btn').disabled = true;
    document.getElementById('reset-btn').textContent = 'Resetting...';

    try {
        const response = await fetch('/reset_channel/' + channelId, { method: 'POST' });
        const data = await response.json();

        if (data.status === 'success') {
            alert('Deleted ' + data.deleted + ' records');
            location.reload();
        } else {
            alert('Reset failed');
            document.getElementById('reset-btn').disabled = false;
            document.getElementById('reset-btn').textContent = 'Reset Channel Data';
        }
    } catch (error) {
        alert('Reset failed: ' + error);
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('reset-btn').textContent = 'Reset Channel Data';
    }
}

// Stats Panel Functions
async function loadContentStats() {
    try {
        const response = await fetch('/content_stats/' + channelId);
        const data = await response.json();

        document.getElementById('stats-loading').classList.add('hidden');

        if (data.error) {
            document.getElementById('stats-empty').classList.remove('hidden');
            document.getElementById('stats-empty').querySelector('span').textContent = data.error;
            return;
        }

        // Check if we have any data
        if (data.video_count_with_duration === 0 && Object.keys(data.activity_timeline).length === 0) {
            document.getElementById('stats-empty').classList.remove('hidden');
            return;
        }

        document.getElementById('stats-content').classList.remove('hidden');

        // Update overview stats
        document.getElementById('total-duration').textContent = data.total_duration_formatted;
        document.getElementById('avg-duration').textContent = data.avg_duration_formatted;
        document.getElementById('videos-analyzed').textContent = data.video_count_with_duration;
        document.getElementById('duplicates-info').textContent =
            data.duplicates_count + ' (' + data.duplicates_size_formatted + ')';

        // Create Duration Distribution Chart
        const durationCtx = document.getElementById('duration-chart').getContext('2d');
        const durationLabels = Object.keys(data.duration_distribution);
        const durationValues = Object.values(data.duration_distribution);

        if (durationChart) durationChart.destroy();
        durationChart = new Chart(durationCtx, {
            type: 'bar',
            data: {
                labels: durationLabels,
                datasets: [{
                    label: 'Videos',
                    data: durationValues,
                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                resizeDelay: 0,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { precision: 0 }
                    }
                }
            }
        });

        // Create Resolution Distribution Chart
        const resolutionCtx = document.getElementById('resolution-chart').getContext('2d');
        const resLabels = Object.keys(data.resolution_distribution);
        const resValues = Object.values(data.resolution_distribution);

        // Filter out zero values for cleaner chart
        const filteredRes = resLabels.map((label, i) => ({label, value: resValues[i]}))
            .filter(item => item.value > 0);

        if (resolutionChart) resolutionChart.destroy();
        resolutionChart = new Chart(resolutionCtx, {
            type: 'doughnut',
            data: {
                labels: filteredRes.map(r => r.label),
                datasets: [{
                    data: filteredRes.map(r => r.value),
                    backgroundColor: [
                        'rgba(239, 68, 68, 0.8)',
                        'rgba(249, 115, 22, 0.8)',
                        'rgba(234, 179, 8, 0.8)',
                        'rgba(34, 197, 94, 0.8)',
                        'rgba(59, 130, 246, 0.8)',
                        'rgba(139, 92, 246, 0.8)'
                    ]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                resizeDelay: 0,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: { boxWidth: 12 }
                    }
                }
            }
        });

        // Create Activity Timeline Chart
        const activityCtx = document.getElementById('activity-chart').getContext('2d');
        const activityLabels = Object.keys(data.activity_timeline);
        const activityValues = Object.values(data.activity_timeline);

        if (activityChart) activityChart.destroy();
        activityChart = new Chart(activityCtx, {
            type: 'line',
            data: {
                labels: activityLabels,
                datasets: [{
                    label: 'Posts',
                    data: activityValues,
                    borderColor: 'rgba(34, 197, 94, 1)',
                    backgroundColor: 'rgba(34, 197, 94, 0.1)',
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                resizeDelay: 0,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { precision: 0 }
                    }
                }
            }
        });

        // Render top content lists
        renderTopList('longest-videos', data.longest_videos, 'duration');
        renderTopList('largest-files', data.largest_files, 'size');

    } catch (error) {
        document.getElementById('stats-loading').classList.add('hidden');
        document.getElementById('stats-empty').classList.remove('hidden');
        document.getElementById('stats-empty').querySelector('span').textContent = 'Failed to load statistics';
    }
}

function renderTopList(elementId, items, type) {
    const container = document.getElementById(elementId);
    container.innerHTML = '';

    if (!items || items.length === 0) {
        container.innerHTML = '<div class="top-item empty">No data</div>';
        return;
    }

    for (const item of items) {
        const div = document.createElement('div');
        div.className = 'top-item';

        const name = item.filename || 'Unknown';
        const truncatedName = name.length > 40 ? name.substring(0, 40) + '...' : name;

        let badge = '';
        if (type === 'duration') {
            badge = item.duration_formatted || '-';
        } else {
            badge = item.size_formatted || '-';
        }

        div.innerHTML = `
            <span class="top-item-name" title="${escapeHtml(name)}">${escapeHtml(truncatedName)}</span>
            <span class="top-item-badge">${badge}</span>
        `;
        container.appendChild(div);
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function startSync() {
    setButtonLoading('sync-btn', true);

    try {
        const response = await fetch('/sync_channel/?channel_id=' + channelId, {
            method: 'POST'
        });
        const data = await response.json();

        if (data.task_id) {
            currentOperation = 'sync';
            setButtonStopMode('sync-btn', 'sync');
            subscribeToProgress(data.task_id, 'sync-btn', 'Syncing storage...', 'sync');
        } else if (data.error) {
            setButtonLoading('sync-btn', false);
            alert('Sync failed: ' + data.error);
        }
    } catch (error) {
        setButtonLoading('sync-btn', false);
        alert('Failed to start sync: ' + error);
    }
}

// Media List Functions
let mediaOffset = 0;
const mediaLimit = 50;
let mediaTotal = 0;

async function loadMediaList(resetOffset = true) {
    if (resetOffset) mediaOffset = 0;

    const typeFilter = document.getElementById('media-type-filter').value;
    const downloadFilter = document.getElementById('download-filter').value;
    const sortBy = document.getElementById('sort-by-filter').value;
    const sortOrder = document.getElementById('sort-order-filter').value;

    let url = `/media_list/${channelId}?limit=${mediaLimit}&offset=${mediaOffset}`;
    if (typeFilter) url += `&media_type=${typeFilter}`;
    if (downloadFilter) url += `&downloaded=${downloadFilter}`;
    url += `&sort_by=${sortBy}&sort_order=${sortOrder}`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        document.getElementById('media-list-loading').classList.add('hidden');
        document.getElementById('media-list').classList.remove('hidden');
        document.getElementById('media-pagination').classList.remove('hidden');

        mediaTotal = data.total;
        document.getElementById('media-count').textContent = `${data.total} items`;

        const list = document.getElementById('media-list');
        list.innerHTML = '';

        if (data.items.length === 0) {
            list.innerHTML = '<div class="no-media">No media found</div>';
            document.getElementById('media-pagination').classList.add('hidden');
            return;
        }

        for (const item of data.items) {
            const row = document.createElement('div');
            row.className = 'media-item' + (item.is_duplicate ? ' duplicate' : '');

            const typeIcon = getTypeIcon(item.media_type);
            const status = item.is_downloaded ? '<span class="status-downloaded">Downloaded</span>' :
                          (item.is_duplicate ? '<span class="status-duplicate">Duplicate</span>' :
                          '<span class="status-pending">Pending</span>');

            let details = [];
            if (item.resolution) details.push(item.resolution);
            if (item.duration_formatted) details.push(item.duration_formatted);
            if (item.size_formatted) details.push(item.size_formatted);

            const name = item.original_filename || item.filename || `Media #${item.tg_message_id}`;
            const date = item.message_date ? new Date(item.message_date).toLocaleDateString() : '';

            row.innerHTML = `
                <div class="media-icon">${typeIcon}</div>
                <div class="media-info">
                    <div class="media-name" title="${escapeHtml(name)}">${escapeHtml(name)}</div>
                    <div class="media-details">${details.join(' | ')}</div>
                    ${item.caption ? `<div class="media-caption">${escapeHtml(item.caption)}</div>` : ''}
                </div>
                <div class="media-meta">
                    <div>${status}</div>
                    <div class="media-date">${date}</div>
                </div>
            `;
            list.appendChild(row);
        }

        updatePagination();
    } catch (error) {
        document.getElementById('media-list-loading').classList.add('hidden');
        document.getElementById('media-list').classList.remove('hidden');
        document.getElementById('media-list').innerHTML = '<div class="no-media">Failed to load media</div>';
    }
}

function getTypeIcon(mimeType) {
    if (!mimeType) return '?';
    if (mimeType.startsWith('video')) return 'V';
    if (mimeType.startsWith('image')) return 'I';
    if (mimeType.startsWith('audio')) return 'A';
    return 'F';
}

function updatePagination() {
    const totalPages = Math.ceil(mediaTotal / mediaLimit);
    const currentPage = Math.floor(mediaOffset / mediaLimit) + 1;

    document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages}`;
    document.getElementById('prev-btn').disabled = mediaOffset === 0;
    document.getElementById('next-btn').disabled = mediaOffset + mediaLimit >= mediaTotal;
}

function prevPage() {
    if (mediaOffset > 0) {
        mediaOffset -= mediaLimit;
        loadMediaList(false);
    }
}

function nextPage() {
    if (mediaOffset + mediaLimit < mediaTotal) {
        mediaOffset += mediaLimit;
        loadMediaList(false);
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    checkActiveTasks();
});
</script>
{% endblock %}
